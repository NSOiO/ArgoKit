//
//  Text.Bind.swift
//  ArgoKit
//
//  Created by xindong on 2020/12/30.
//

import Foundation

extension Text {
    /// change the rgba-color of the text.
    /// - Parameters:
    ///   - r: the red value of the color object, data range from 0 to 255.
    ///   - g: the green value of the color object, data range from 0 to 255.
    ///   - b: the blue value of the color object, data range from 0 to 255.
    ///   - a: the opacity value of the color object, data range from 0 to 1.
    /// - Returns: self
    @discardableResult
    public func textColor(red r:Int,green g :Int,blue b:Int,alpha a:CGFloat = 1)->Self{
        let value = UIColor(red: CGFloat(Double(r)/255.0), green: CGFloat(Double(g)/255.0), blue: CGFloat(Double(b)/255.0), alpha: a)
        addAttribute(#selector(setter:UILabel.textColor),value)
        return self;
    }
    
    /// change the rgba-color of the text
    /// - Parameters:
    ///   - hex: rgb color, ex: 0xaabbcc representing the red value is 0xaa, the green value is 0xbb and the blue value is 0xcc.
    ///   - a: the opacity value of the color object, data range from 0 to 1.
    /// - Returns: self
    @discardableResult
    public func textColor(hex:Int,alpha a:Float = 1)->Self{
        let value = ArgoKitUtils.color(withHex: hex,alpha:a)
        addAttribute(#selector(setter:UILabel.textColor),value)
        return self;
    }
    
    /// set the shadow offset, in points, for the text
    /// - Parameter value: new offset value
    /// - Returns: self
    @discardableResult
    public func textShadowOffset(_ value:CGSize)->Self{
        addAttribute(#selector(setter:UILabel.shadowOffset),value)
        return self
    }
    
    /// set the shadow color for the text
    /// - Parameter value: a new color
    /// - Returns: self
    @discardableResult
    public func textShadowColor(_ value:UIColor)->Self{
        addAttribute(#selector(setter:UILabel.shadowColor),value)
        return self
    }
    
    /// set the shadow color for the text, the color is generated by the rgba value.
    /// - Parameters:
    ///   - r: red value of the color object, data range form 0 to 255
    ///   - g: green value of the color object, data range form 0 to 255
    ///   - b: blue value of the color object, data range form 0 to 255
    ///   - a: opacity value of the color object, data range form 0 to 255
    /// - Returns: self
    @discardableResult
    public func textShadowColor(red r:Int,green g :Int,blue b:Int,alpha a:CGFloat = 1)->Self{
        let value = UIColor(red: CGFloat(Double(r)/255.0), green: CGFloat(Double(g)/255.0), blue: CGFloat(Double(b)/255.0), alpha: a)
        addAttribute(#selector(setter:UILabel.shadowColor),value)
        return self;
    }
    
    /// set the shadow color for the text, the color is generated by the rgba value.
    /// - Parameters:
    ///   - hex: rgb value of the color object, ex: 0xaabbcc representing red value is 0xaa, green value is 0xbb, blue value is 0xcc.
    ///   - a: opaity value of the color object, data range from 0 to 1.
    /// - Returns: self
    @discardableResult
    public func textShadowColor(hex :Int,alpha a:Float = 1)->Self{
        let value = ArgoKitUtils.color(withHex: hex,alpha:a)
        addAttribute(#selector(setter:UILabel.shadowColor),value)
        return self;
    }
    
    /// The technique for wrapping and truncating the label’s text. Call lineBreakMode of the UILabel directly.
    /// - Parameter value: new line break mode
    /// - Returns: self
    ///
    ///```
    ///public enum NSLineBreakMode : Int {
    ///
    ///    case byWordWrapping = 0 // Wrap at word boundaries, default
    ///
    ///    case byCharWrapping = 1 // Wrap at character boundaries
    ///
    ///    case byClipping = 2 // Simply clip
    ///
    ///    case byTruncatingHead = 3 // Truncate at head of line: "...wxyz"
    ///
    ///    case byTruncatingTail = 4 // Truncate at tail of line: "abcd..."
    ///
    ///    case byTruncatingMiddle = 5 // Truncate middle of line:  "ab...yz"
    ///}
    ///```
    @discardableResult
    public func breakMode(_ value:NSLineBreakMode)->Self{
        addAttribute(#selector(setter:UILabel.lineBreakMode),value.rawValue)
        return self
    }
    
    /// set the highlight color for the text.
    /// - Parameter value: new color
    /// - Returns: self
    @discardableResult
    public func highlightedTextColor(_ value:UIColor?)->Self{
        addAttribute(#selector(setter:UILabel.highlightedTextColor),value)
        return self
    }
    
    /// set a Boolean value that determines whether the label draws its text with a highlight.
    /// - Parameter value: a Boolean value
    /// - Returns: self
    @discardableResult
    public func isHighlighted(_ value:Bool)->Self{
        addAttribute(#selector(setter:UILabel.isHighlighted),value)
        return self
    }
    
    
    /// Set A Boolean value that determines whether the system ignores and removes user events for this label from the event queue.
    /// - Parameter value: a Boolean value
    /// - Returns: self
    @discardableResult
    public func userInteractionEnabled(_ value:Bool)->Self{
        addAttribute(#selector(setter:UILabel.isUserInteractionEnabled),value)
        return self
    }
    /// set a Boolean value that determines whether the back label draws its text in an enabled state.
    /// - Parameter value: a Boolean value
    /// - Returns: self
    public func isEnabled(_ value:Bool)->Self{
        addAttribute(#selector(setter:UILabel.isEnabled),value)
        return self
    }
    
    /// Set the maximum number of lines for rendering text. 0 representing unlimited.
    /// - Parameter value: new maximum number of lines.
    /// - Returns: self
    @discardableResult
    public func lineLimit(_ value:Int)->Self{
        addAttribute(#selector(setter:UILabel.numberOfLines),value)
        return self
    }
    
    /// A Boolean value that determines whether the label reduces the text’s font size to fit the title string into the label’s bounding rectangle.
    /// - Parameter value: a new Boolean value
    /// - Returns: self
    @discardableResult
    public func adjustsFontSizeToFitWidth(_ value:Bool)->Self{
        addAttribute(#selector(setter:UILabel.adjustsFontSizeToFitWidth),value)
        return self
    }
    
    /// An option that controls whether the text's baseline remains fixed when text needs to shrink to fit in the label.
    /// - Parameter value: new option
    /// - Returns: self
    ///
    ///```
    ///public enum UIBaselineAdjustment : Int {
    ///
    ///    case alignBaselines = 0 // default. used when shrinking text to position based on the original baseline
    ///
    ///    case alignCenters = 1
    ///
    ///    case none = 2
    ///}
    ///```
    @discardableResult
    public func baselineAdjustment(_ value:UIBaselineAdjustment)->Self{
        addAttribute(#selector(setter:UILabel.baselineAdjustment),value)
        return self
    }

    
    /// The minimum scale factor for the label’s text.
    /// - Parameter value: scale factor
    /// - Returns: self
    @available(iOS 6.0, *)
    @discardableResult
    public func minimumScaleFactor(_ value:CGFloat)->Self{
        addAttribute(#selector(setter:UILabel.minimumScaleFactor),value)
        return self
    }

    /// A Boolean value that determines whether the label tightens text before truncating.
    ///
    /// When the value of this property is true, the label tightens intercharacter spacing of its text before allowing any truncation to occur. The label determines the maximum amount of tightening automatically based on the font, current line width, line break mode, and other relevant information. This autoshrinking behavior is only intended for use with a single-line label.
    /// The default value of this property is false.
    /// - Parameter value: new Boolean value
    /// - Returns: self
    @available(iOS 9.0, *)
    @discardableResult
    public func allowsDefaultTighteningForTruncation(_ value:Bool)->Self{
        addAttribute(#selector(setter:UILabel.allowsDefaultTighteningForTruncation),value)
        return self
    }

    /// A Boolean value that determines whether the label tightens text before truncating.
    ///
    /// When the value of this property is true, the label tightens intercharacter spacing of its text before allowing any truncation to occur. The label determines the maximum amount of tightening automatically based on the font, current line width, line break mode, and other relevant information. This autoshrinking behavior is only intended for use with a single-line label.
    /// The default value of this property is false.
    /// - Parameter value: a new Boolean value.
    /// - Returns: self
    @discardableResult
    public func lineBreakStrategy(_ value:NSParagraphStyle.LineBreakStrategy)->Self{
        addAttribute(#selector(setter:UILabel.allowsDefaultTighteningForTruncation),value)
        return self
    }
    
    /// The preferred maximum width, in points, for a multiline label.
    /// - Parameter value: new value
    /// - Returns: self
    @available(iOS 6.0, *)
    @discardableResult
    public func preferredMaxLayoutWidth(in value: CGFloat)->Self{
        addAttribute(#selector(setter:UILabel.preferredMaxLayoutWidth),value)
        return self
    }
}
